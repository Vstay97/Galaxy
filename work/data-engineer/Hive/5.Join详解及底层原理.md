---
title: Join详解及底层原理 ⭐️⭐️⭐️
description: Join详解及底层原理
keywords:
- Hive
tags:
- Hive
sidebar_position: 5
author: Vstay
date: 2025-10-13 14:51
last_update:
  author: Vstay
  date: 2025-10-13
---

> 掌握 ⭐️⭐️⭐️

## 6.3.1 join的类型

### 1. 等值 inner Join

Hive 只支持等值连接、外连接。老版 Hive 不支持非相等的 join 条件（通过其他方式实现），随着 Hive 版本的发展，逐渐支持不等值连接。Hive 还可以 join 两个以上的表。

**数据案例**，下面操作以此数据作为观察对象。

**订单表：**`ds_hive.ch6_t_order`

| order_id | user_id | product |
| -------- | ------- | ------- |
| 1        | 1       | 商品 1    |
| 2        | 2       | 商品 2    |
| 3        | 3       | 商品 3    |
| 4        | 4       | 商品 4    |


**用户表：**`ds_hive.ch6_t_user`

| user_id | user_name |
| ------- | --------- |
| 1       | user1     |
| 5       | user5     |
| 3       | user3     |
| 7       | user7     |

#### 案例实操

内连接：只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。如下图：

![](https://cdn.jsdelivr.net/gh/Vstay97/Img_storage@main/blog/2025/Join%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20251013164638665.png)

**(1) 查询每个用户的订单。**

```sql
hive (default)>
select t1.id
       ,t2.username
from ds_hive.ch6_t_order t1
join ds_hive.ch6_t_user t2
    on t1.user_id=t2.id;
```

最终只会保留两张表中 user_id 都存在的数据。

| order_id | user_id | product | user_name |
|----------|---------|---------|-----------|
| 1        | 1       | 商品1   | user1     |
| 3        | 3       | 商品3   | user1     |

### 2. 外关联 left join 、right join

#### 左外连接 (left join)
左外连接：join 操作符左边表中符合 where 子句的所有记录将会被返回。如下图：

![](https://cdn.jsdelivr.net/gh/Vstay97/Img_storage@main/blog/2025/Join%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20251013164638666.png)

```sql
hive (default)>
select t1.id
       ,t2.username
from ds_hive.ch6_t_order t1
Left join ds_hive.ch6_t_user t2
    on t1.user_id=t2.id
;
```

最终左表的数据全部保留，右边保留 user_id 存在左表中的数据。

| order_id | user_id | product | user_name |
|----------|---------|---------|-----------|
| 1        | 1       | 商品1   | user1     |
| 2        | 2       | 商品2   | null      |
| 3        | 3       | 商品3   | user3     |
| 4        | 4       | 商品4   | null      |

#### 右外连接 (right join)
右外连接：join 操作符右边表中符合 where 子句的所有记录将会被返回。

![](https://cdn.jsdelivr.net/gh/Vstay97/Img_storage@main/blog/2025/Join%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20251013164638667.png)

```sql
hive (default)>
select t1.id
       ,t2.username
from ds_hive.ch6_t_order t1
right join ds_hive.ch6_t_user t2
    on t1.user_id=t2.id
;
```

最终右表的数据全部保留，左边保留 user_id 存在左表中的数据。

| order_id | user_id | product | user_name |
|----------|---------|---------|-----------|
| 1        | 1       | 商品1   | user1     |
| null     | 5       | null    | user5     |
| 3        | 3       | 商品3   | user3     |
| null     | 7       | null    | user7     |

### 3. 实现非等值连接

查询 test_a 有，test_b 没有，用 `left join` + `is null`

![](https://cdn.jsdelivr.net/gh/Vstay97/Img_storage@main/blog/2025/Join%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20251013164638668.png)

```sql
select t1.id
       ,t2.username
from ds_hive.ch6_t_order t1
left join ds_hive.ch6_t_user t2
    on t1.user_id=t2.id
where t2.id is null
;
```

### 4. 满外连接 (full join)

满外连接：将会返回所有表中符合 where 语句条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用 null 值替代。

![](https://cdn.jsdelivr.net/gh/Vstay97/Img_storage@main/blog/2025/Join%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20251013164638669.png)

```sql
hive (default)>
select t1.id
       ,t2.username
from ds_hive.ch6_t_order t1
full join ds_hive.ch6_t_user t2
    on t1.user_id=t2.id
;
```

```sql
hive (default)>
select t1.id
       ,t2.username
from ds_hive.ch6_t_order t1
full join ds_hive.ch6_t_user t2
    on t1.user_id=t2.id
;
```

| order_id | user_id | product | user_name |
|----------|---------|---------|-----------|
| 1        | 1       | 商品1   | user1     |
| 2        | 2       | 商品2   | null      |
| 3        | 3       | 商品3   | user3     |
| 4        | 4       | 商品4   | null      |
| null     | 5       | null    | user5     |
| null     | 7       | null    | user7     |

### 5. 多表连接

注意：连接 n 个表，至少需要 n-1 个连接条件。例如：连接三个表，至少需要两个连接条件。

#### 多表连接查询

```sql
hive (default)>
select t1.id
       ,t2.username
       ,t3.product_name
       ,t3.price
from ds_hive.ch6_t_order t1
join ds_hive.ch6_t_user t2
    on t1.user_id=t2.id
join ds_hive.ch6_t_goods t3
    on t1.product_id=t3.id
;
```

### 6. 要避免的笛卡尔集

#### 1）笛卡尔集会在下面条件下产生

1.  省略连接条件
2.  连接条件无效
3.  所有表中的所有行互相连接

#### 2）案例实操

```sql
hive (default)>
select t1.id
       ,t2.username
from ds_hive.ch6_t_order t1
join ds_hive.ch6_t_user t2
    on 1=1
;
```

我们上面给大家演示了各种关联，都是一对一比如内关联的1对1最终的结果为：

| order_id | user_id | product | user_name |
|----------|---------|---------|-----------|
| 1        | 1       | 商品1   | user1     |
| 3        | 3       | 商品3   | user1     |

但是很多时候，还会存在一对多，多对一，多对多的问题。

比如一对多的情况，最终关联结果为：

![](https://cdn.jsdelivr.net/gh/Vstay97/Img_storage@main/blog/2025/Join%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20251013164638670.png)

多对多的情况，最终关联结果为：

![](https://cdn.jsdelivr.net/gh/Vstay97/Img_storage@main/blog/2025/Join%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20251013164638671.png)

可以看出，当多对多的的时候，数据是成倍数增加的，当使用了笛卡尔积时，连接条件无效，那就相当于全表的多对多，数据增加数据不可想象。那我们可以通过设置参数来避免这样的查询。

```sql
set hive.mapred.mode=strict;
```

设置这个参数，可以限制以下情况：

1.  限制执行可能形成笛卡尔积的SQL；
2.  partition 表使用时不加分区；
3.  order by 全局排序的时候不加 limit 的情况；

### 7. 联合（union & union all）

#### 1）union & union all 上下拼接

`union` 和 `union all` 都是上下拼接 sql 的结果，这点是和 join 有区别的，join 是左右关联，union 和 union all 是上下拼接。**`union` 去重，`union all` 不去重。**

`union` 和 `union all` 在上下拼接 sql 结果时有两个要求：

1.  两个 sql 的结果，列的个数必须相同
2.  两个 sql 的结果，上下所对应列的类型必须一致

#### 2）案例实操

将用户表和订单表的用户 id，利用 `union all` 进行拼接显示。

```sql
hive (default)>
select t1.user_id as user_id
from ds_hive.ch6_t_order t1
union all
select t2.id as user_id
from ds_hive.ch6_t_user t2
;
```

```sql
select t1.user_id as user_id
from ds_hive.ch6_t_order t1
union
select t2.id as user_id
from ds_hive.ch6_t_user t2
;
```

### 8. left semi join

**`LEFT SEMI JOIN` 以一种高效的方式实现了不相关的 `IN/EXISTS` 子查询语义。 在 Hive 0.13 中，`IN/NOT IN/EXISTS/NOT EXISTS` 操作符被支持使用子查询，所以大多数 join 操作不再需要手动执行。 使用 `LEFT SEMI JOIN` 的限制是，右边的表只能在连接条件(on子句)中引用，而不能在 `WHERE` 或 `SELECT` 子句等中引用。**

1.  `left semi join` 的限制是， JOIN 子句中右边的表只能在 ON 子句中设置过滤条件，在 WHERE 子句、SELECT 子句或其他地方过滤都不行。
2.  因为 `left semi join` 是 `in(keySet)` 的关系，遇到右表重复记录，左表会跳过，而 `join` 则会一直遍历。这就导致右表有重复值得情况下 `left semi join` 只产生一条，`join` 会产生多条，也会导致 `left semi join` 的性能更高。

#### 使用

用 `left semi join`:
```sql
select  t1.id
        ,t1.user_id
        ,t1.quantity
        ,t2.id
     from ds_hive.ch6_t_order   t1
left semi join ds_hive.ch6_t_user t2
       on t1.user_id=t2.id
```

代替 `IN` 子查询:
```sql
select  t1.id
        ,t1.user_id
        ,t1.quantity
     from ds_hive.ch6_t_order   t1
    where  id in (select  distinct id from ds_hive.ch6_t_user)
;
```